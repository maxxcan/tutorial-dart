#+title: resumen-dart
#+author: Patricio Martínez
#+email: maxxcan@disroot.org

* Prefacio 

Este tutorial sobre dart es una traducción más o menos literal de la página [[https://www.tutorialspoint.com/dart_programming/dart_programming_syntax.htm][tutorialspoint]]. 

* Introducción 

Dart es un lenguaje open-source de propósito general. Originalmente desarrollado por Google y más tarde aprovado como un estándar por ECMA. Dart es un nuevo lenguaje de programación destinado para servidores así como para navegadores. Introducido por Google, el *Dart SDK* viene con su compilador - el *Dart VM*. El SDK también incluye una utilidad *dart2js*, un transpilador que general código JavaScript equivalente de un script de Dart. 

* Resumen 

Dart es un lenguaje orientado a objetos con sintaxis de estilo C el cual puede opcionalmente trans compilar en JavaScript. Soporta una variedad de rangos de ayudas a la programación como interfaces, clases, colecciones, genéricos, y tipos opcionales. 

Dart puede ser extensivamente usado para crear aplicaciones de una sola página. Las aplicaciones de una sola página aplicadas a sitios web y aplicaciones web. Las aplicaciones de una sola página tienen navegación entre diferentes pantallas del sitio web sin cargar una página diferente en el navegador. Un ejemplo clásico es *GMail* - cuando pinchamos en un mensaje de nuestra entrada de correo, el navegador permanece en la misma página, pero el código de JavaScript esconde la entrada de correo y trae el cuerpo del mensaje a la pantalla. 

Google ha desarrollado una construcción especial de *Chromium* - el *Dart VM*. Usando Dartium significa que no tenemos que compilar nuestro código a JavaScript antes de que estemos preparados para testearlo en otros navegadores. 

La siguiente tabla compara las características de Dart y JavaScript. 

| Característica   | Dart                     | JavaScript        |
|------------------+--------------------------+-------------------|
| Sistema de tipos | Opcional, dinámico       | Débil, dinámico   |
| Clases           | Sí, herencia simple      | Prototípica       |
| Interfaces       | Sí, múltiples interfaces | No                |
| Concurrencia     | S, con aislamiento       | Si, con HTML5 web |

* Entorno

* Sintaxis 

La sintaxis define un conjunto de reglas para escribir programas. Cada especificación del lenguaje define su propia sintaxis. Un programa de Dart está compuesto de - 

+ Variables y operadores
+ Clases 
+ Funciones
+ Expresiones y constructores de programación
+ Toma de decisiones y constructores de bucles 
+ Comentarios
+ Bibliotecas y paquetes
+ Definiciones de tipos
+ Estructuras de datos representadas como colecciones / genéricos 

** Nuestro primer Código en Dart

Vamos a empezar con el tradicional ejemplo "Hola Mundo" - 

#+BEGIN_SRC dart
main(){
  print("Hola Mundo");
}
#+END_SRC


La función *main()* es un método predefinido en Dart. Este método actúa como el punto de entrada a la aplicación. Un guión de Dart necesita el método *main()* para la ejecución. *print()* es una función predefinida que dibuja una cadena de caracteres especificada o un valor a la salida estándar, es decir, la terminal. 

La salida del código anterior será - 

: Hola Mundo!

** Ejecutando un programa de Dart

Podemos ejecutar un programa de Dart de dos formas - 

+ Vía la terminal

+ Vía el IDE WebStorm 

*** Vía la terminal 

Para ejecutar un programa de Dart vía la terminal - 

+ Navegar hasta la ruta del proyecto actual

+ Escribir el siguiente comando en la ventana de la terminal 

: dart nombre_fichero.dart 

** Opciones de la línea de comandos en Dart 

Las opciones de la línea de comandos en Dart son usadas para modificar la ejecución del guión de Dart. Las opciones más comunes son: 

| Nº | Opciones         | Descripción                                                                                      |
|----+------------------+--------------------------------------------------------------------------------------------------|
|  1 | --version        | Muestra la versión del VM                                                                        |
|  2 | --packages<ruta> | Especifica la ruta al fichero de configuracion de la resolución del paquete                      |
|  3 | -p<ruta>         | Especifica donde encontar la biblioteca importada. Esta opción no puede ser usada con --packages |
|  4 | -h o --help      | Muestra la ayuda                                                                                 |


** Identificadores en Dart 

Los identificadores son nombres dados a los elementos en un programa como variables, funciones, etc. Las reglas para los identificadores son - 

Los identificadores pueden incluir ambos, caracteres y dígitos. Sin embargo, los identificadores no pueden empezar con un dígito. 

+ Los identificadores no pueden incluir símbolos especiales excepto el guión bajo (_) o el signo del dolar ($).
+ Los identificadores no pueden ser palabras clave
+ Los identificadores deben ser únicos.
+ Los identificadores son sensibles a mayúsculas y minúsculas.
+ Los identificadores no pueden contener espacios.

La siguiente tala lista unos ejemplos de identificadores válidos e inválidos - 

| Identificadores válidos | Identificadores inválidos |
|-------------------------+---------------------------|
| firstName               | Var                       |
| first_name              | first name                |
| num1                    | first-name                |
| $result                 | 1number                   |

** Palabras claves en Dart 

Las palabras claves tienen un significado especial en el contexto del lenguaje. La siguiente tabla lista algunas palabras clave en Dart 

| abstract1 | continue  | false      | new       | this     |
| as1       | default   | final      | null      | throw    |
| assert    | deferred1 | finally    | operator1 | true     |
| async2    | do        | for        | part1     | try      |
| async*2   | dynamic1  | get1       | rethrow   | typedef1 |
| await2    | else      | if         | return    | var      |
| break     | enum      | implemnts1 | set1      | void     |
| case      | export1   | import1    | static1   | while    |
| catch     | external1 | in         | super     | with     |
| class     | extends   | is         | switch    | yield2   |
| const     | factory1  | library1   | sync*2    | yield*2  |

** Espacios en blanco y saltos de línea 

Dart ignora los espacios, tabuladores, y saltos de carro que aparecen en el programa. Podemos usar espacios, tabuladores, y saltos de carro libremente en nuestro programa y somos libres de sangrar los programas en una forma limpia y consistente para hacer el código más fácil de leer y entender. 

** Dart es sensible a mayúsculas y minúsculas 

Dart es sensible a mayúsculas y minúsculas. Esto significa que Dart diferencia entre caractéres en mayúsculas y minúsculas. 

** Las declaraciones terminan con un punto y coma 

Cada línea de una instrucción es llamada una declaración. Cada declaración en dart debe terminar con un punto y coma(;). Un simple línea puede contener múltiples declaraciones. Sin embargo, esas declaraciones deben estar separadas por un punto y coma. 

** Comentarios en Dart 

Los comentarios son una forma de mejorar la legibilidad de un programa. Los comentarios pueden ser usados para incluir información adicional sobre un programa como el autor del código, pistas sobre una función/constructor etc. Los comentarios son ignorados por el compilador. 

Dart soporta los siguientes tipos de comentarios. 

+ Comentarios de una sola línea (//) - Cualquier texto entre un "//" y el final de una línea es tratado como un comentario 
+ Comentarios multilínea. (/**/)- Esos comentarios pueden tener múltiples líneas. 

Ejemplo 

#+BEGIN_SRC dart 
// esto es un comentario de una línea 

/* Esto es un 
comentario multilínea
*/
#+END_SRC

** Programación orientada a objetos en Dart 

Dart es un lenguaje orientado a objetos. La orientación a objetos es un paradigma del desarrollo de software que sigue un modelo del mundo real. La orientación a objetos considera un programa como una colección de objetos que se comunican unos con otros con un mecanismo llamado método. 

+ *Objeto*  - Un objeto es una representación en tiempo real de cualquier entidad. Como por Grady Brooch, cada objeto debe tener tres características. 
  + *Estado* -- descrito por los atributos de un objeto. 
  + *Comportamiento* -- describe como el objeto actuará. 
  + *Identidad* -- Un valor único que distingue un objeto de un conjunto de objetos similares. 
+ *Clase* -- Una clase en terminos del POO es un plano para crear objetos. Una clase encapsula datos para el objeto. 
+ *Método* -- Los métodos facilitan la comunicación entre objetos. 

Ejemplo: Dart y la Orientación a Objetos 

#+BEGIN_SRC dart 
class TestClass{
void disp(){
print("Hello World";
}
}
void main(){
TestClass c = new TestClass();
c.disp();
}
#+END_SRC

En el ejemplo anterior definimos una clase *TestClass*. La clase tiene un método *disp()*. El método dibuja la cadena de texto "Hello World" en el terminal. La palabra clave *new* crea un objeto de la clase. El objeto invoca el método *disp()*. 

El código producirá la siguiente salida - 

: Hello World

* Tipos de datos 

Una de las características más fundamentales de un lenguaje de programación es el conjunto de tipos de datos que soporta. Son los tipos de valores que pueden ser representados y manipulados en un lenguaje de programación. 

Dart soporta los siguientes tipos: 

+ Números
+ Cadenas de caracteres 
+ Buleanos 
+ Listas
+ Mapas

** Números 

Los números en Dart son usados para representar números literales. Los números en dat vienen en dos tipos - 

+ *Enteros* - Valores enteros representan valores no fraccionales, es decir, valores numéricos sin punto decimal. Por ejemplo, el valor de "10" es un entero. Los enteros son representados usando la palabra clave *int*. 
+ *Dobles* - Dart También soporta valores numéricos fracionales, es decir, valores con punto decimal. El tipo de dato doble representa un número de 64-bit (doble-precisión) de coma flotante. Por ejemplo, el valor "10.10". La palabra clave *double* es usada para representar estos números. 

** Cadenas de texto 

Las cadenas de texto representan una cadena de caracteres. Por ejemplo, si necesitamos guardar algún tipo de dato como nombre, dirección, etc, el tipo de dato tipo cadena de texto suele ser usado. Una cadena de texto en Dart es una secuencia de unidades de código UTF-16. *Runas* son usadas para representar una secuencia de unidades de código UTF-32. 

La palabra clave *String* es usada para representar cadenas de texto. Las cadenas de texo son embebidas entre comillas dobles o simples. 

** Booleanos 

Los tipos de datos booleanos representan valores de tipo lógico verdadero o falso. Dart usa la palabra clave *bool* para representar un valor Booleano. 

** Listas y Mapas 

Los tipos de datos listas y mapas son usados para representar una colección de objetos. Una *Lista* es un grupo ordenado de objetos. El tipo de dato Lista en Dart es sinónimo del concepto de array en otros lenguajes. El tipo de dato *Mapa* representa un conjunto de valores como pares clave-valor. La biblioteca *dart:core* habilita la creación y manipulación de esas colecciones a través de las clases predefinidas List y Map, respectivamente. 

** El tipo dinámico 

Dart es un lenguaje opcionalmente de tipado dinámico. Si el tipo de una variable no se especifica, el tipo de la variable es *dinámico*. La palabra clave *dynamic* es también usada como un tipo de anotación explícito. 


* Variables 

Una variable es "un espacio de memoria nombrado" que guarda valores. En otras palabras, actúa como un contenedor para los valores de un programa. Los nombres de las variables son llamados identificadores. A continuación mostramos las reglas de nombrado para un identificador - 

+ Los identificadores no pueden ser palabras clave
+ Los identificadores pueden contener letras y números 
+ Los identificadores no pueden contener espacios o caracteres especiales, excepto el guión bajo (_) y el signo del dolar ($). 
+ Los nombres de variables no pueden empezar con un número.

** Sintaxis tipo 

Una variable debe ser declarada antes de ser usada. Dart usa la palabra clave *var* para archivar el mismo. La sintaxis para declarar una variable es la siguiente - 

#+BEGIN_SRC dart 
var name = 'Smith';
#+END_SRC

Todas las variables en dart guardan una referencia al valor en vez de contener el valor. La variable llamada "name" contiene una referencia a un objeto cadena de caracteres con un valor de "Smith". 

%% dibujo 

Dart soporta *comprobador de tipos* por prefijando el nombre de la variable con el tipo de dato. El comprobador de tipos asegura que una variable guarda solo el dato espeificado como un tipo de dato. La sintaxis para el mismo es dado a continuación - 

#+BEGIN_SRC dart 
String name = 'Smith';
int num = 10;
#+END_SRC

Consideremos el siguiente ejemplo - 

#+BEGIN_SRC dart 
  void main(){
    String name = 1;
  }
#+END_SRC

El código anterior dará como resultado un aviso error que avisa que el valor asignado a la variable no coincide con el tipo de dato de la variable. 

Salida. 

: Error: A value of type 'int' can't be assigned to a variable of type 'String'.
:  String name = 1;

Todas las variables no inicializadas tienen el valor inicial de null. Esto es porque Dart considera todos los valores como objetos. El siguiente ejemplo lo ilustra. 

#+BEGIN_SRC dart 
  void main(){
    int num;
    print(num);
  }
#+END_SRC

Salida 
: null

***  La palabra clave dynamic 

Las variables declaradas sin un tipo estático son implícitamente declaradas como dinámicas. Las variables también pueden ser declaradas usando la palabra clave *dynamic* en lugar de la palabra clave *var*. 

Veamos el siguiente ejemplo - 

#+BEGIN_SRC dart 
void main(){
dynamic x = "tom";
print(x);
}
#+END_SRC

Salida 
: tom 

** Final y Const 

Las palabras clave *final* y *const* son usadas para declarar constantes. Dart impide modificar los valores de una variable declarada usando las palabras clave final o const. Esas palabras clave pueden ser usadas en conjunción con el tipo de dato de la variable o en vez de la palabra clave *var*. 

La palabra clave *const* es usada para representar una constante en tiempo de compilación. Las variables declaradas usando la palabra clave *const* son implicitamente final. 

*** Sintaxis: final 
: final nombre_variable

o 

: final tipo_de_dato nombre_variable

*** Sintaxis: const 

: const nombre_variable

o 

: const tipo_de_dato nombre_variable

*** Ejemplo - final 

#+BEGIN_SRC dart 
void main(){
final vall = 12;
print(vall);
}
#+END_SRC

#+RESULTS:
: 12

*** Ejemplo - const 

#+BEGIN_SRC dart 
void main(){
const pi = 3.14;
const area = pi*12*12;
print("La salida es el ${area}");
}
#+END_SRC

El ejemplo anterior declara dos constantes. 

Sólo las variables *const* puede ser usadas para calcular una constante en tiempo de compilación. 

* Operadores 

Una expresión es un tipo especial de declaración que evalúa a un valor. Cada expresión está compuesto por - 

+ *Operandos* - Representan los datos 
+ *Operador* - Define como los operandos serán procesados para producir un valor. 

Consideremos la siguiente expresión -- "2 + 3". En esta expresión, 2 y 3 son *operandos* y el símbolo "+" (suma) es el *operador*. 

En este capítulo, discutiremos los operadores que están disponibles en Dart. 

+ Operadores artiméticos
+ Operadores de igualdad y relacionales
+ Operradores de tipo test 
+ Operadores a nivel de bits
+ Operadores de asignación
+ Operadores lógicos 

** Operadores aritméticos 

La siguiente tabla muestra los Operadores artiméticos que soporta Dart. 

| Nº | Operador | Significado                                    |
|----+----------+------------------------------------------------|
|  1 | +        | Suma                                           |
|  2 | -        | Resta                                          |
|  3 | -expr    | Unitario menos, también conocido como negación |
|  4 | *        | Multiplicación                                 |
|  5 | /        | División                                       |
|  6 | ~/       | División, devolviendo un resultado entero      |
|  7 | %        | Modulo.                                        |
|  8 | ++       | Incremento                                     |
|  9 | --       | Decremento                                     |


** Operadores de igualdad y relacionales

Los Operadores relacionales comprueban o definen el tipo de relación entre dos entidades. Los operadores relacionales devuelven un valor Booleano, es decir, verdadero o falso. 

Asumimiendo que A es 10 y B es 20

| Operador | Descripción       | Ejemplo              |
|----------+-------------------+----------------------|
| >        | Mayor Que         | (A>B) es Falso       |
| <        | Menor que         | (A<B) es Verdadero   |
| >=       | Mayor o igual que | (A>=B) es Falso      |
| <=       | Menor o igual qu  | (A<=B) ess Verdadero |
| ==       | Igual a           | (A==B) es Falso      |
| !=       | No igual          | (A!=B) es Verdadero  |


** Operadores de tipo test 

Esos Operadores son útiles para comprobar tipos en tiempo de ejecución 

| Operadores | Significado                                       |
|------------+---------------------------------------------------|
| is         | Verdadero si el objeto tiene el tipo especificado |
| is!        | Falso si el objeto tiene el tipo especificado     |

** Operadores a nivel de Bit 

La siguiente tabla lista los operadores a nivel de bits en Dart y su función -

| Operador                   | Descripción | Ejemplo                                                                                                       |
|----------------------------+-------------+---------------------------------------------------------------------------------------------------------------|
| AND                        | a & b       | Devuelve un uno en cada posición de bit por el cual los correspondientes bits o ambos Operadores son uno.     |
| OR                         | a¦b         | Devuelve un uno en cada posición de bit por el cual los correspondientes bits o alguno o ambos son unos       |
| XOR                        | a^b         | Devuelve un uno en cada posición de bit por el cual los correspondientes bits de ellos pero no ambos son unos |
| NOT                        | ~a          | Invierte los bits de sus Operadores                                                                           |
| Corrimiento a la izquierda | a « b       | Desplaza a en representación binaria b(<32) a la izquierda, dejando ceros a la derecha                        |
| Corrimiento a la derecha   | a » b       | Desplaza a en representación binaria b(<32) a la derecha                                                      |

** Operadores de asignación 

| Nº | Operadores | Descripción                           |
|----+------------+---------------------------------------|
|  1 | =          | Asignación simple                     |
|  2 | ??=        | Asigna solo si la variable es null    |
|  3 | +=         | Suma y asigna. C += A -> C = C + A    |
|  4 | -=         | Sustrae y asigna. C -= A -> C = C - A |
|  5 | *=         | Multiplica y asigna                   |
|  6 | /=         | Divide y asigna                       |

*Nota*. La misma lógica se aplica a los operadores sobre Bits, así ellos se convertirán en «=, »=,»=,»=,|= y ^=. 

** Operadores lógicos 

Los Operadores lógicos son usados para combinar dos o más condiciones. Los Operadores lógicos devuelven un valor booleano. Asumiendo el valor de la variable A es 10 y B es 20. 

| Operadores | Descripción                                                                    | Ejemplo                   |
|------------+--------------------------------------------------------------------------------+---------------------------|
| &&         | AND- El operador devuelve verdadero si todas las expresiones lo hacen          | (A>10&&B>10) es Falso     |
| ¦¦         | OR - El operador devuleve verdadero si al menos una de las expresiones lo hace | (A>10¦¦B>10) es Verdadero |
| \!         | NOT - El operador devuelve lo contrario del resultado de la expresión          | !(A>10) es Verdadero      |


** Expresiones condicionales 

Dart tiene dos operadores que permiten evaluar expresiones que podrían de otra forma requerir una declaración ifelse - 

: condition ? expr1 : expr2 

Si la condición es verdadera, entonces la expresión evalúa la *expr1* (y devuelve su valor): de otra forma, evaluará y devolverá el valor de *expr2* 

: expr1 ?? expr2 

Si la *expr1* es non-null, devolverá su valor; de otra forma, evaluará y devolverá el valor de *expr2*

** Ejemplo  

El siguiente ejemplo muestra como podemos usar expresiones condicionales en Dart - 

#+BEGIN_SRC dart 
  void main(){
    var a = 10;
    var res = a > 12 ? "valor mayor que 10":"valor menor o igual que 10";
    print(res);
  }
#+END_SRC

Esto producirá el siguiente resultado - 

: valor menor o igual que 10

Veamos otro ejemplo 

#+BEGIN_SRC dart 
  void main(){
    var a = null;
    var b = 12;
    var res = a ?? b;
    print(res);
  }
#+END_SRC


Esto producirá el siguiente resultado - 

: 12 

* Bucles 

A veces, cierta instrucción requiere una ejecución repetida. Los bucles son una forma ideal de hacerlo. Un bucle representa un conjunto de instrucciones que deben ser repetidas. En el contexto de un bucle, una repetición es llamado una *iteración*. 

La siguiente figura ilustra la clasificación de los bucles - 

[[./images/bucles.png]]


Empezaremos la discusión con bucles definidos. Un bucle cuyo numero de ingteraciones está definido/fijado es llamado *bucle definido* 

| Nº | Bucle    | Descripción                                                   |
|----+----------+---------------------------------------------------------------|
|  1 | for      | Ejecuta el bloque de código un número especificado de veces.  |
|  2 | for...in | Es usado para hacer bucles a través de propiedades de objetos |

Ahora discutiremos los bucles indefinidos. Un bucle indefinido es usado cuando el número de iteraciones en un bucle es indeterminado o desconocido. Los bucles indefinidos pueden ser implementados usando - 

| Nº | Bucle      | Descripción                                                                                      |
|----+------------+--------------------------------------------------------------------------------------------------|
|  1 | while      | El bucle se ejecuta cada vez que la condición especificada evalúa a verdadero                    |
|  2 | do...while | Es similar al anterior excepto que no evalúa la condición la primera vez que el bucle se ejecuta |

Vamos la discusión a *las Declaraciones de Control de los Bucles* en Dart. 

| Nº | Declaración de Control | Descripción                                     |
|----+------------------------+-------------------------------------------------|
|  1 | break                  | Se usa para sacar el control fuera del bucle    |
|  2 | continue               | Vuelve el control del bucle al principo de este |

** Ejemplos 

** Usando Etiquetas para el Control del Flujo 

Una *etiqueta* es solo un identificador seguido de dos puntos (:) que es aplicado a la declaración o al bloque de código. Una etiqueta puede ser usada con *break* y *continue* para controlar el flujo de forma más precisa. 

El salto de línea no está permitido entre la declaración *'continue'* o *'break'* el nombre de su etiqueta. Además, no debería haer otra declaración entre el nombre de una etiqueta y su bucle asociado. 

Ejemplo de Etiqueta con Break 

#+BEGIN_SRC dart 
  void main(){
  outerloop: // esto es el nombre de la etiqueta 

  for (var i = 0; i < 5; i++){
      print("Buccle Interior: ${i}");
      innerloop:

      for (var j = 0; j < 5; j++){
	if (j > 3) break;

	// Salida del bucle Interior
	if (i == 2) break innerloop;

	// Hacer lo mismo
	if (i == 4) break outerloop;

	// Salida del bucle exterior 
	print("Bucle Interior: ${j}");
      }
    }
  }

  #+END_SRC

La salida mostrará lo siguiente: 

: Bucle Interior: 0 
: Bucle Interior: 0
: Bucle Interior: 1
: Bucle Interior: 2
: Bucle Interior: 3
: Bucle Interior: 1
: Bucle Interior: 0
: Bucle Interior: 1
: Bucle Interior: 2
: Bucle Interior: 3
: Bucle Interior: 2
: Bucle Interior: 3
: Bucle Interior: 0
: Bucle Interior: 1
: Bucle Interior: 2
: Bucle Interior: 3
: Bucle Interior: 4

Ejemplo de Etiqueta con continue 

#+BEGIN_SRC dart 
  void main(){
  outerloop: // Esto es el nombre de la Etiqueta

  for (var i = 0; i < 3; i++){
      print("BucleExterno:${i}");

      for (var j = 0; j < 5; j++){
	if (j == 3){
	  continue outerloop;
	}
	print("BucleInterno:${j}");
      }
    }
  }
  #+END_SRC

La salida será la siguiente: 

: BucleExterno: 0
: BucleInterno: 0
: BucleInterno: 1
: BucleInterno: 2

: BucleExterno: 1
: BucleInterno: 0
: BucleInterno: 1
: BucleInterno: 2

: BucleExterno: 2
: BucleInterno: 0
: BucleInterno: 1
: BucleInterno: 2


* Tomando decisiones 

  Un constructor para la toma de decisiones/condicional evalúa una condición antes de que la instrucción sea ejecutada. 

  [[./images/cond.png]]

  Los constructures condicionales  en Dart están clasificados en la siguiente tabla.

| Nº | Declaración   | Descripción                                                                                |
|----+---------------+--------------------------------------------------------------------------------------------|
|  1 | if            | Consiste en una expresión booleana seguida de uno o más Declaraciones                      |
|  2 | if...Else     | Es un if con un bloque condicional que se ejecutará si el primero es falso                 |
|  3 | else...if     | Es útil para comprobar múltiples condiciones                                               |
|  4 | switch...case | Evalúa una expresión, compara el valor a un caso y ejecuta la declaración asociada al caso |

** Ejemplos 

* Números 

Los números en Dart pueden ser clasificados como - 

+ *Enteros* - Entero de tamaño arbitrario. El tipo de dato entero (*int*) es usado para representar gran cantidad de números. 
+ *doble* - 64-bits (doble-precisión) números de coma flotante, tal como son especificados por el estándar IEEE 754. El tipo de dato doble (*double*) es usando para representar números fraccionales. 

El tipo *num* es inherente a los tipos *entero* y *doble*. La *biblioteca central de Dart* permite numerosas operaciones sobre los valores numéricos. 

La sintaxis para declarar un número es la siguiente - 

#+BEGIN_SRC dart 
int nombre_variable;      // Declara una variable entera
double nombre_variable;  // Declara una variable doble
#+END_SRC

Ejemplo: 

#+BEGIN_SRC dart
  void main(){
    // declarando un entero 
    int num1 = 10;

    // declarando un valor doble
    double num2 = 10.50;

    // imprime los valores 
    print(num1);
    print(num2);
  } 
#+END_SRC

Esto producirá la siguiente salida - 

: 10 
: 10.5

** Analizando 

La funcion estántica *parse()* permite analizar una cadena conteniendo un número literal en un número. El siguiente ejemplo lo demuestra - 

#+BEGIN_SRC dart 
  void main(){
    print(num.parse('12'));
    print(num.parse('10.91'));
  }
#+END_SRC

Lo que mostrará la siguiente salida - 

: 12 
: 10.91

La función *parse* lanzará un *FormatException* si pasamos cualquier valor que no sea un número. El siguiente código muestra como pasr un valor alfa-numérico a la función *parse()* 

Ejemplo 

#+BEGIN_SRC dart 
  void main(){
    print(num.parse('12A'));
    print(num.parse('AAAA'));
  }
#+END_SRC

Lo que producirá el siguiente resultado - 

#+BEGIN_SRC
Unhandled exception:
FormatException: 12A
#0      num.parse (dart:core/num.dart:474:26)
#1      main (file:///home/maxxcan/aa.dart:2:13)
#2      _startIsolate.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:301:19)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:168:12)
#+END_SRC

** Propiedades de los números 

La siguiente tabla lista las propiedades soportadas por los números en Dart. 

| Nº | Propiedad  | Descripción                                              |
|----+------------+----------------------------------------------------------|
|  1 | hashcode   | Devuelve un código resumen de un valor numérico          |
|  2 | isFinite   | Verdadero si el número es finito                         |
|  3 | isInfinite | Verdadero si el número es infinito                       |
|  4 | isNan      | Verdadero si el númro es el doble No-un-Número           |
|  5 | isNegative | Verdadero si el número es negativo                       |
|  6 | sign       | Devuelve menso uno, cero o más uno dependiendo del signo |
|  7 | isEven     | Verdadero si el numero es par                            |
|  8 | isOdd      | Verdadero si el número es impar                          |

*** Ejemplos 

** Métodos numéricos 

Veamos los métodos soportados por los números en Dart - 

| Nº | Método    | Decripción                                                         |
|----+-----------+--------------------------------------------------------------------|
|  1 | abs       | Devuelve el valor absoluto del número                              |
|  2 | ceil      | Devuelve un entero no más pequeño que el número                    |
|  3 | compareTo | Compara dos números                                                |
|  4 | Floor     | Devuelve el mayor número no mayor al número dado                   |
|  5 | remainder | Devuelve el resto después de dividir dos números                   |
|  6 | Round     | Devuelve el entero más cercano al número dado                      |
|  7 | toDouble  | Devuelve el equivalente doble del número                           |
|  8 | toInt     | Devuelve el equivalente entero del número                          |
|  9 | toString  | Devuelve el equivalente de texto del número                        |
| 10 | truncate  | Devuelve un entero después de decartar cualquier número fraccional |

*** Ejemplos 

* Cadena de caractéres 

Los datos tipo cadadena de caractéres repreentan una secuencia de caracteres. Una cadena de carateres en Dart es una secuencia de codificación de unidad UTF-16

Los valores de cadena de caracteres en Dart pueden ser repreentados usando comillas simples o dobles. Una sola línea se representa con comillas dobles o sencillas. Las comillas triples son usadas para representar cadena de caracteres multilínea. 

La sintaxis para representar cadenas de caracteres en Dart se muestra a continuación - 

** Sintaxis 

#+BEGIN_SRC dart 
String nombre_variable = 'valor'

OR 

String nombre_variable = ''valor'' 

OR

String nombre_variable = '''linea1

OR 

String nombre_variable= ''''''linea1
linea2''''''
#+END_SRC

Los siguientes ejemplos ilustran el uso de la cadena de caracteres en Dart 

#+BEGIN_SRC dart 
  void main(){
    String str1 = 'Esto es una línea de caracteres';
    String str2 = "Esto es una línea de carateres";
    String str3 = '''Esto es una multilínea de caracteres''';
    String str4 = """Esto es una multilinea de caracteres""";

    print(str1);
    print(str2);
    print(str3);
    print(str4);
  }
#+END_SRC

Esto producirá la siguiente salida - 

: Esto es una línea de caracteres 
: Esto es una línea de caracteres 
: Esto es una multilínea de caracteres 
: Esto es una multilínea de caracteres 

Las cadenas de caracteres son inmutables. Sin embargo, pueden ser sujetas a varias operaciones y la cadena de texto resultante será guardada como un nuevo valor. 

** Interpolación en cadenas de caracteres 

El proceso de crear una nueva cadena de caracteres por agregación de un valor a una cadena estática es llamado como *concatenación* o *interpolación*. En otras palabras, es el proceso de añadir una cadena de caracteres a otra. 

El operador suma (+) es comúnmente usado ccomo mecanismo de concatenar/interpolar cadenas de caracteres. 

*** Ejemplo 1

#+BEGIN_SRC dart 
  void main(){
    String str1 = "Hola";
    String str2 = "Mundo";
    String res = str1+str2;

    print("La cadena concatenada es: ${res}")
  }
#+END_SRC

La salida que se producirá será: 

: La cadena concatenada es: HolaMundo

*** Ejemplo 2 

Podemos usar "${}" para interpolar el valor de una expresión en Dart con cadenas de caracteres. El siguiente ejemplo  lo ilustra. 

#+BEGIN_SRC dart 
  void main(){
    int n=1+1;

    String str1 = "La suma de 1 y 1 es ${n}";
    print(str1);

    String str2 = "La suma de 2 y 2 es ${2+2}";
    print(str2);
#+END_SRC

Esto producirá la siguiente salida 

: La suma de 1 y 1 es 2
: La suma de 2 y 2 es 4

** Propiedades de las cadenas de caracteres 

La siguiente tabla muestra las propiedades de las cadenas de caracters en Dart

| Nº | Propiedades | Descripción                                                                                  |
|----+-------------+----------------------------------------------------------------------------------------------|
|  1 | codeUnits   | Devuelve una lista de inamobibles códigos UTF-16                                             |
|  2 | isEmpty     | Devuelve verdadero si la cadena está vacía                                                   |
|  3 | Length      | Devulve la longitud de la cadena incluyedo espacios en blanco, tabuladores y saltos de línea |
|    |             |                                                                                              |

*** Ejemplos 

** Métodos para manipular cadenas de caracteres 

La clase Cadena de caracteres en la *biblioteca core de Dart* también proporciona métodos para manipular cadenas de caracteres. Algunos de esos métodos son mostrados a continuación - 

| Nº | Método        | Descripción                                                                        |
|----+---------------+------------------------------------------------------------------------------------|
|  1 | toLowerCase() | Convierte los caratéres a minúsculas                                               |
|  2 | toUpperCase() | Convierte los caracteres a mayúsculas                                              |
|  3 | trim()        | Devuelve la cadena sin espacios delante o detrás                                   |
|  4 | compareTo()   | Compara este objeto a otro                                                         |
|  5 | replaceAll()  | Reemplaza todas las subcadenas especificadas con un patrón, con un valor dado      |
|  6 | split()       | Corta la cadena con un número delimitado de caracteres dando lugar a subcaracteres |
|  7 | substring()   | Devuelve subcadenas siguiendo un índice                                            |
|  8 | toString()    | Devuelve un representación de cadena de caracteres de este objeto                  |
|  9 | codeUnitAt()  | Devuelve la codificación UTF-16 de un índice dado                                  |

*** Ejemplos 

* Booleanos 

Dart proporciona soporte interno para tipo de datos booleanos. Los tipos booleanos en Dart soporta solo dos valores - verdadero y falso. La palabra clave *bool* es usada para representar un booleano literal en Dart. 

La sintaxis para declarar una variable booleana en Dart es la siguiente - 

#+BEGIN_SRC dart 
bool nombre_variable = true;
OR
bool nombre_variable  false;
#+END_SRC

** Ejemplo 

#+BEGIN_SRC dart 
void main(){
bool test;
test = 12 > 5;
print(test);
}
#+END_SRC

Producirá la salida 

: true 

** Ejemplo 

A diferencia de JavaScript, el tipo de dato booleano solo reconoce el literal true como true.. Cualquier otro valor será reconocido como falso. Consideremos el siguiente ejemplo - 

#+BEGIN_SRC dart 
  var str = 'abc';
  if(str) {
    print('La cadena no está vacía');
  } else {
    print('Cadena vacía');
  }
#+END_SRC

El código anterior, si se ejecutase en JavaScript, mostraría el mensaje 'La cadena no está vacía' como si el constructor devolviera true si la cadena no lo estuviera.

Sin embargo, en Dart, *str* se convierte en falso como str != true. Aquí el código mostrará el mensaje de 'Cadena vacía'. 

** Ejemplo 

El siguiente código arrojará una excepción. 

#+BEGIN_SRC dart 
  void main(){
    var str = 'abc';
    if(str) {
      print('La cadena no está vacía');
    } else {
      print('Cadena vacía');
    }
  }
#+END_SRC

Producirá la siguiente salida 

#+BEGIN_SRC dart 
aa.dart:3:6: Error: A value of type 'String' can't be assigned to a variable of type 'bool'.
  if(str){
     ^
#+END_SRC

* Listas 

Algo muy usado en programación son los *array*. Dart representa los arrays en la forma de objetos *Lista*. Una *Lista* es solo un grupo de objetos. La biblioteca *dart:core* proporciona la clase List que habilita la creación y manipulación de listas. 

La representación lógica de una lista en Dart es la siguiente - 

[[./images/lista.png]]

+ *test_list* - es el identificador que refiere la colección
+ La lista contiene en ella los valores 12, 13 y 14. Los bloques de memoria mantienen esos valores que son conocidos como *elementos*.
+ Cada elemento en la Lista es identificado por un número único llamado *índice*. El índice empieza desde *cero* y se extiende *n-1* donde *n* es el número total de elementos en la Lista. El índice es también refereido como el *subscript*. 

La lista puede ser clasificada como - 

+ Lista de longitud fija
+ Lista ampliable 

Vamos ahora a discutir esos dos tipos de *listas* en detalle.

** Lista de longitud fija



Una lista de longitud fija no puede cambiar en tiempo de ejecución. La sintaxis para crear una lista de longitud fija es la siguiente, es como sigue. 

*** Declarando una lista 

La Sintaxis para declarar una lista es la siguiente - 

#+BEGIN_SRC dart 
var nombre_lista = new List(tamaño_inicial)
#+END_SRC

La sintaxis anterior crea una lista de tamaño especificado. La lista no puede crecer o disminuir en tiempo de ejecución. Cualquier intento de cambiarle el tamaño resultaría en una excepción. 

*** Inicializando una lista 

La Sintaxis para inicializar una lista dada es la siguiente - 

#+BEGIN_SRC dart 
nombre_lista[indice] = valor;
#+END_SRC

Ejemplo 

#+BEGIN_SRC dart 
  void main() {
    var lst = new List(3);
    lst[0] = 12;
    lst[1] = 13;
    lst[2] = 11;

    print(lst);
  }
#+END_SRC


Esto producirá el siguiente resultado 

: [12, 13, 11]
   

** Lista ampliable 

Una lista ampliable puede cambiar en tiempo de ejecución. La sintaxis para declarar e inicializar un lista ampliable es la siguiente - 

*** Paso 1 - Declarando una lista 

#+BEGIN_SRC dart 
var nombre_lista = [val1, val2, val3]
--- crea una lista que contiene valores espcificados 
OR 
var nombre_lista = new List()
--- crea una lista de tamaño cero 
#+END_SRC

*** Paso 2 - Inicializando una lista 

El índice/subscript es usado para referenciar el elemento que podría ser poblando con un valor. La sintaxis para inicializar una lista es dada a continuación - 

#+BEGIN_SRC dart 
nombre_lista[indice] = valor;
#+END_SRC


Ejemplo 

El siguiente ejemplo muestra como crear una lista de 3 elementos. 

#+BEGIN_SRC dart 
  void main(){
    var num_list = [1,2,3];
    print(num_list);
  }
#+END_SRC

Esto producirá el siguiente resultado - 

: [1, 2, 3]

Ejemplo 

El siguiente ejemplo crea una lista de longitud cero usando el *constructor empty List()*. La función *add()* en la clase *List* es usada dinamicamente para añadir elementos a la lista. 

#+BEGIN_SRC dart 
  void main(){
    var lst = new List();
    lst.add(12);
    lst.add(13);
    print(lst);
  }
#+END_SRC

Que producirá el siguiente resultado - 

: [12, 13]


** Propiedades de las listas 

La siguiente tabla lista las propiedades más communmente usadas de la clase *List* de la biblioteca *dart:core* 

| Nº | Métodos    | Descripción                                                                     |
|----+------------+---------------------------------------------------------------------------------|
|  1 | first      | Devuelve el primer elemento                                                     |
|  2 | isEmpty    | Devuelve verdadero si la colección no tiene elementos                           |
|  3 | isNotEmpty | Devuelve Verdadero si la colección tiene al menos un elemento                   |
|  4 | length     | Devuelve el tamaño de la lista                                                  |
|  5 | last       | Devuelve el último elemento de la lista                                         |
|  6 | reversed   | Devuelve un obbjeto repetible que contiene la lista de valores en orden inverso |
|  7 | Single     | Compruea si la lista tiene solo un elemento y lo devuelve                       |

*** Ejemplos 
** Operaciones básicas en las Listas 

En la siguiente tabla veremos algunas operaciones básicas que se pueden realizar en una Lista como - 

| Nº | Operación                       | Descripción                                                                     |
|----+---------------------------------+---------------------------------------------------------------------------------|
|  1 | Insertar elementos              | Esto se hace con la función *List.add()*                                        |
|  2 | Actualizar una lista            | Se puede hacer actualizando el índice o usando la función *List.replaceRange()* |
|  3 | Eliminiar elementos de la lista | Se puede hacer con las siguientes funciones que veremos en los ejemplos         |

* Mapa 

El objeto Mapa es un simple par clave/valor. Claves y valores en un mapa pueden ser cualquier tipo de dato. Un Mapa es una colección dinámica. En otras palabras, los Mapas pueden crecer o disminuir en tiempo de ejecución. 

Los Mapas pueden ser declarados de dos formas - 

+ Usando el Literal Map
+ Usando un constructor Map 

** Declarando un Mapa usnado el Literal Map 

Para declarar un mapa usando el literal Map, necesitamos encerrar el par clave/valor entre llaves *"{}"*. 

Aquí la sintaxis 

#+BEGIN_SRC dart 
var identificador = { clave1:valor1, clave2:valor2, [,.. . . clave_n:valor_n] }
#+END_SRC

** Declarando un mapa usando un constructor Map 

Para declarar un mapa usando un constructor Map, tenemos que dar dos pasos. Primero, declarar el mapa y segundo inizializar el mapa. 

La *sintasis* para *declarar un mapa* es la siguiente 

#+BEGIN_SRC dart 
var identificador = new Map()
#+END_SRC

Ahora, usaremos la siguiente sintaxis para *inicializar el mapa* - 

#+BEGIN_SRC dart 
nombre_mapa[clave] = valor
#+END_SRC

** Ejemplos 

Ejemplo: Literal Map 

#+BEGIN_SRC dart 
  void main(){
    var details = {'nombre':'Tom', 'Contraseña':'1234'};
    print(details);
  }
#+END_SRC

Producirá la siguiente salida - 

: {nombre: Tom, Contraseña: 1234}

Ejemplo: Añadiendo valores al Mapa Literal en tiempo de ejecución 

#+BEGIN_SRC dart 
  void main(){
    var details = {'nombre':'tom', 'Contraseña':'1234'};
    details['Uid'] = 'U1001';
    print(details);
  }
#+END_SRC

Esto producirá el siguiente resultado - 

: {nombre: tom, Contraseña: 1234, Uid: U1001}

Ejemplo: Constructor Map 

#+BEGIN_SRC dart 
  void main(){
    var details = new Map();
    details['Nombre'] = 'admin';
    details['Contraseña'] = '1234';
    print(details);
  }
#+END_SRC


Esto producirá la siguiente salida -

: {Nombre: admin, Contraseña: 1234}

*Nota* - Un valor de un mapa puede ser cuaulquier objeto incluído NULL 

** Propiedades de los Mapas 

La clase *Map* del paquete dart:core define las siguientes propiedades 

| Nº | Propiedad  | Descripción                                            |
|----+------------+--------------------------------------------------------|
|  1 | Keys       | Devuelve un objeto repetible representando claves      |
|  2 | Values     | Devuelve un objeto repetible representando los valores |
|  3 | Length     | Devuelve el tamaño del Mapa                            |
|  4 | isEmpty    | Devuelve verdadero si el mapa está vacío               |
|  5 | isNotEmpty | Devuelve verdadero si el Mapa no está vacío            |

** Funciones de los Mapas 

Lo siguiente son las funciones más usadas para manipular Mapas en Dart 

| Nº | Nombre de la función | Descripción                                          |
|----+----------------------+------------------------------------------------------|
|  1 | addAll()             | Añade todos los pares clave-valor de un mapa a otro  |
|  2 | clear()              | Elimina todos los pares del Mapa                     |
|  3 | remove()             | Elimina la clave y valor asociado si existe del Mapa |
|  4 | forEach()            | Aplica f a cada par clave-valor del Mapa             |

** Ejemplos 


* Símbolos 

Los símbolos en Dart son opacos, nombres de caractéres dinámicos usados en reflejar metadatos desde una librería. Simplemente poner, símbolos son una forma de guardar la relación entre una cadena leíble por un humano y una cadena que esté optimizada para ser usada por las computadoras. 

Reflección es un mecanismo para obtener metadatos de un tipo en tiempo de ejecución como el número de métodos en una clase, el número de constructores que tiene o el número de parámetros en una función. Podemos incluso invocar un método del tipo el cual es cargado en tiempo de ejecución. 

En Dart la reflección específica de clases está disponible en el paquete *dart:mirrors*. Esta biblioteca funciona tanto en aplicaciones web como en aplicaciones de línea de comandos. 

** Sintaxis  

#+BEGIN_SRC dart 
Symbol obj = new Symbol('nombre');
// espera el nombre de una clase o función o biblioteca para reflejar 
#+END_SRC

El *nombre* debbe ser un nombre de miembro público válido en Dart, nombre de constructor público, o nombre de biblioteca.

** Ejemplo

Consideremos el siguiente ejemplo. El código declara una clase *Foo* en una biblioteca *foo_lib*. La clase define los métodos *m1, m2, y m3*. 

*Foo.dart*

#+BEGIN_SRC dart 
  library foo_lib;
  // el nombre de la biblioteca puede ser un símbolo

  class Foo {
    // el nombre de la clase puede ser un símbolo
    m1(){
      // El nombre del método puede ser un símbolo
      print("Dentro de m1");
    }
    m2(){
      print("Dentro de m2");
    }
    m3(){
      print("Dentro de m3");
    }
  }

#+END_SRC 

El siguiente código carga la biblioteca *Foo.dart* y busca la clase Foo, con la ayuda del tipo Symbol. Desde que tenemos la Reflección el metadato desde la biblioteca anterior el código importa la biblioteca *dart:mirrors*. 

*FooSymbol.dart* 

#+BEGIN_SRC C
  import 'dart:core';
  import 'dart:mirrors';
  import 'Foo.dart';

  main(){
    Symbol lib = new Symbol("foo_lib");
    // nombre de la biblioteca guardado como un símbolo

    Symbol clsToSearch = new Symbol("Foo");
    // nombre de la clase guardada como un símbolo

    if(checkIf_classAvailableInlibrary(lib, clsToSearch))
      // buscando la clase Foo en la biblioteca foo_lib
      print("clase encontrada..");
  }

  bool checkIf_classAvailableInlibrary(Symbol libraryName, Symbol className){
    MirrorSystem mirrorSystem = currentMirrorSystem();
    LibraryMirror libMirror = mirrorSystem.findLibrary (libraryName);

    if (libMirror != null){
      print("Biblioteca encontrada");
      print("comprobando..detalles de clase");
      print("La clase no encontrada es : ${libMirror.declarations.length}");
      libMirror.declarations.forEach((s, d) => print(s));

      if (libMirror.declarations.containsKey(className)) return true;
      return false;
    }
  }

#+END_SRC  

Fijemonos que la línea libMirror.declarations.forEach((s, d) => print(s)); iterará a través de toda la declaración en la biblioteca en tiempo de ejecucion y mostrará la declaracíon como tipo de *Symbol*.

Este código producirá el siguiente resultado

#+BEGIN_SRC 
Biblioteca encontrada
comprobando..detalles de clase
La clase no encontrada es : 1
Symbol("Foo")
clase encontrada.
#+END_SRC

Ejemplo: Mostrando el número de métodos instanciados de una clase 

Vamos a considerar el mostrar el número de métodos instanciados en una clase. La clase predefinida *ClassMirror* nos ayudará a conseguir lo mismo. 

#+BEGIN_SRC dart 
  import 'dart:core';
  import 'dart:mirrors';
  import 'Foo.dart';

  main(){
    Symbol lib = new Symbol("foo_lib");
    Symbol clsToSearch = new Symbol("Foo");
    reflect_InstanceMethods (lib, clsToSearch);
  }

  void reflect_InstanceMethods (Symbol libraryName, Symbol className){
    MirrorSystem mirrorSystem = currentMirrorSystem();
    LibraryMirror libMirror = mirrorSystem.findLibrary (libraryName);

    if (libMirror != null){
      print("Biblioteca encontrada");
      print("comprobando.. detalle de clase");
      print("La clase no encontrada es: ${libMirror.declarations.length}");
      libMirror.declarations.forEach((s, d) => print(s));

      if (libMirror.declarations.containsKey(className)) print("clase encontrada");
      ClassMirror classMirror = libMirror.declarations[className];

      print("La instancia del método no encontrado es ${classMirror.instanceMembers.length}");
     classMirror.instanceMembers.forEach((s, v) => print(s)); 
    }
  }
#+END_SRC

Este código producirá la siguiente salida - 

#+BEGIN_SRC
Biblioteca encontrada
comprobando.. detalle de clase
La clase no encontrada es: 1
Symbol("Foo")
clase encontrada
La instancia del método no encontrado es 8
Symbol("==")
Symbol("hashCode")
Symbol("toString")
Symbol("noSuchMethod")
Symbol("runtimeType")
Symbol("m1")
Symbol("m2")
Symbol("m3")
#+END_SRC

** Convirtiendo Símbolos a cadenas de texto 

Podemos convertir el nombre de un tipo como clase o biblioteca guardado en un símbolo a cadena de texto usando la clase *MirrorSystem*. El siguiente código muestra como podemos hacerlo. 

#+BEGIN_SRC dart 
  import 'dart:mirrors';
  void main(){
    Symbol lib = new Symbol("foo_lib");
    String name_of_lib = MirrorSystem.getName(lib);

    print(lib);
    print(name_of_lib);
  }
#+END_SRC

Esto producirá la siguiente salida - 

#+BEGIN_SRC
Symbol("foo_lib")
foo_lib
#+END_SRC




* Clases 

  Dart es un lenguaje orientado a objetos. Soporta características de programación orientada a objetos como clases, interfaces, etc. Una clase en terminos de OOP es un plano para crear objetos. Una clase encapsula datos para el objeto. Dart ofrece soporte para este concepto llamado *clase*. 

** Declarando una clase 

   Se usa la palabra clave *class* para declarar un clase. Una definición de clase empieza con la palabra clave class seguido de un *nombre de clase*; y el cuerpo encerrado por un par de llaves. La sintaxis es la siguiente: 

   #+BEGIN_SRC 
   Syntax 

   class class_name {
<campos>
<getters/setters>
<constructores>
<funciones>
}
   #+END_SRC

   La palabra clave *class* es seguida por el nombre de la clase. Las reglas para los identificadores deben ser consideradas también para los nombres de clases.

   Un definición de clase puede incluir lo siguiente: 

   - *Campos* - Un campo es cualquier variable declarada en una clase. Los campos representan datos pertenecientes a lo objetos.
   - *Setters y Getters* - Permiten al programa iniciar y recibir valores de los campos de una clase. Un getter/setter por defecto es asociado con cada clase. Sin embargo, éste puede ser anulado definiendo explícitamente un setter/getter.
   - *Constructores* - Responsables de asignar memoria para el objeto de la clase. 
   - *Funciones* - Las funciones representan las acciones que un objeto puede tomar. También son referidas como *métodos*.

   Esos componentes puestos juntos son denominados como los datos de los miembros de la clase. 

   Ejemplo:

   #+BEGIN_SRC dart 
  class Car {
    // campo
    String engine = "E1001";

    // función
    void disp() {
      print(engine);
    }
  }
   #+END_SRC

   En el ejemplo declaramos una clase llamada *Car*. La clase tiene un campo llamado *engine*. Y una simple función *disp()* que escribe el valor del campo *engine*.

** Creando una instancia de la clase 

   Para crear una instancia de la clase, usamos la palabra clave *new* seguido del nombre de la clase. La sintaxis es la siguiente:

   #+BEGIN_SRC 
Syntax

var nombre_del_objeto = new nombre_clase([ argumentos ])
   #+END_SRC

   + La palabra clave *new* es responsable de la instanciación. 
   + El lado derecho de la expresión invoca al constructor. El constructor puede pasar valores si son parametrizados.

   /Ejemplo de una instancia de clase/

   #+BEGIN_SRC dart
  var obj = new Car("Engine 1")
   #+END_SRC

** Accediendo a Atributos y Funciones

   Los atributos y funciones de una clase pueden ser accedidos a través del objeto. Usando la *notación de punto* (llamado *periodo*) para acceder a los miembros de los datos de una clase.

   #+BEGIN_SRC dart
//accediendo a un atributo
obj.nombre_del_campo

//accediendo a una función
obj.nombre_de_la_función()
   #+END_SRC

   /Ejemplo/

   Echemos un ojo al siguiente ejemplo para entender como acceder a los atributos y funciones en Dart

   #+BEGIN_SRC dart
  void main(){
    Car c= new Car();
    c.disp();
  }
  class Car {
    // campo
    String engine = "E1001";

    //función
    void disp() {
      print(engine);
    }
  }
   #+END_SRC

   La salida del código anterior es el siguiente - 

   : E1001

** Constructores en Dart

   Un constructor es una función especial de la clase que es la responsable de inicializar las variables de la clase. Dart define un constructor con el mismo nombre de la clase. Un constructor es una función y por lo tanto puede ser parametrizada. Sin embargo, a diferencia de una función, los constructores no pueden tener un tipo de retorno. Si no se declara un constructor, un constructor sin argumentos por defecto es proporcionado por tí. 

   /Sintáxis/

   #+BEGIN_SRC 
Nombre_de_la_Clase(lista_de_parámetros){
//cuerpo del constructor
}
   #+END_SRC

   El siguiente ejemplo muestra como se usa un constructor en Dart. 

   #+BEGIN_SRC dart
  void main(){
    Car c = new Car('E1001');
  }
  class Car {
    Car(String engine) {
      print(engine);
    }
  }

   #+END_SRC

   Esto dará la siguiente salida - 

   : E1001

** Constructores nombrados (Named Constructor)

   Dart proporciona *named constructor* para habilitar una definición de clase con múltiples constructores. La sintaxis es la siguiente- 

   /Sintáxis: Definiendo el constructor/

   #+BEGIN_SRC 
Nombre_clase.nombre_constructor(lista_de_parámetros)
   #+END_SRC

   Ejemplo:

   #+BEGIN_SRC dart
  void main() {
    Car c1 = new Car.namedConst('E1001');
    Car c2 = new Car();
  }
  class Car {
    Car(){
      print("Constructor sin parámetros invocado");
    }
    Car.namedConst(String engine) {
      print("El motor es : ${engine}");
    }
  }
   #+END_SRC

   Esto producirá la siguiente salida:

   : El motor es: E1001
   : Constructor sin parámetros invocado

** La palabra clave /this/

   La palabra clave *this* se refiere a la instancia actual de la clase. Aquí, el parámetro llamado y el nombre del campo de la clase son el mismo. Por lo tanto para evitar la ambigüedad, el campo de la clase se le pone el prefijo *this*. El siguiente ejemplo explica ésto.

   /Ejemplo/

   El siguiente ejemplo explica como usar la palabra clave *this* en Dart

   #+BEGIN_SRC dart
  void main(){
    Car c1 = new Car('E1001');
  }
  class Car {
    String engine;
    Car(String engine){
      this.engine = engine;
      print("El motor es : ${engine}")
    }
  }
   #+END_SRC

   Esto dará como resultado:

   : El motor es : E1001

** Getters and setters

   Getters and Setters, también llamados accesores (accessors) y mutadores (mutators), permiten al programa inicializar y recibir los valores de los campos de las clases respectivamente. Getters o accesores son definidos usando la palabra clave get. Los Setters o mutadores son definidos usando la palabra clave set.

   Un setter/getter por defecto es asociado a cada clase. Sin embargo, pueden ser invalidados definiendolos explícitamente. Un getter no tiene parámetros y devuelve un valor, y un setter tiene un parámetro y no devuelve ningún valor. 

   /Sintáxis: Definiendo un getter/

   #+BEGIN_SRC 
Return type get identificador
{
}
   #+END_SRC

   /Sintáxis: Definiendo un setter/ 

   #+BEGIN_SRC 
set identificador 
{
}
   #+END_SRC

   /Ejemplo/

   El siguiente ejemplo muestra como usar getters y setters en Dart - 

   #+BEGIN_SRC dart
  class Student{
    String name;
    int age;

    String get stud_name {
      return name;
    }
    void set stud_name(String name){
      this.name = name;
    }

    void set stud_age(int age){
      if(age<= 0){
        print("La edad debe ser mayor que 5");
      } else {
        this.age = age;
      }
    }

    int get stud_age {
      return age;
    }
  }

  void main() {
    Student s1 = new Student();
    s1.stud_name = 'Pedro';
    s1.stud_age = 0;
    print(s1.stud_name);
    print(s1.stud_age);
  }
   #+END_SRC

   Este programa producirá la siguiente salida 

   : La edad debe ser mayor que 5
   : Pedro
   : Null

** Herencia de clase

   Dart soporta el concepto de herencia el cual es la habilidad de un programa  de crear una nueva clase de una clase existente. La clase que es extendida para crear nuevas clases es llamada clase padre o superclase. La clase nueva creada es llamada la clase hija o subclase. 

   Una clase hereda de otra clase usando la palabra clave 'extends'. Las clases hijas heredan todas las propiedades y métodos, excepto el constructor de la clase padre. 

   /Sintáxis/

   : class nombre_clase_hija extends nombre_clase_hija

   *Nota*. Dart no soporta la herencia múltiple. 

   /Ejemplo de herencia de clase/

   En el siguiente ejemplo, vamos a declarar una clase Forma. La clase es extendida por la clase Círculo. 

   #+BEGIN_SRC dart

  void main(){
    var obj  new Circle();
    obj.cal_area();
  }

  Class Shape {
    void cal_area(){
      print("llamando al cálculo de area definido en la clase Forma");
    }
  }
  class Circle extends Shape {}

   #+END_SRC

   Esto produce la siguiente salida - 

   : llamando al cáluclo de area definido en la clase Forma

*** Tipos de Herencia 

    La herencia puede seguir tres tipos - 

    1) *Simple* - Cada clase puede al menos extender de una clase padre
    2) *Múltiple* - Una clase puede heredar de múltiples clases. Dart no soporta la herencia múltiple
    3) *Multi-level* - Una clase puede heredar de otra clase hija. 

El siguiente ejemplo muestra como funciona la herencial Multi-level. 

#+BEGIN_SRC dart
  void main(){
  var obj = new Leaf();
  obj.str = "hola";
  print(obj.str);
  }
  Class Raíz {
  String str;
  }
  class Hijo extends Raíz {}
  class Hoja extends Hijo {}
  // indirectamente hereda de Raíz por virtud de la herencia
#+END_SRC

La clase Hoja deriva sus atributos de las clases Raíz e Hijo por virtud de la herencia multi-level. La salida será - 

: hola

** Herencia de clase y anulación de métodos

La anulación de Métodos es un mecanismo por el cual la clase hija redefine un método en la clase padre. El siguiente ejemplo ilustra esto -

#+BEGIN_SRC dart
  void main(){
    Hijo h = new Hijo();
    h.m1(12);
  }
  Class Padre {} {
    void m1(int a) { print ("El valor de a ${a}");}
  }
  class Hijo extends Parent {
    @override
    void m1(int b){
      print("el valor de b ${b}");
    }
  }
#+END_SRC

La salida será: 

: el valor de b 12

** La palabra clave /static/

La palabra clave *static* puede ser aplicada a los miembros de datos de una clase, es decir, *campos y métodos*. Una variable estática retiene su valor hasta que el programa termina la ejecución. Los miembros estáticos son referenciados por un nombre de clase. 

/Ejemplo/

#+BEGIN_SRC dart
  class MemoriaStatica {
    static int num;
    static disp() {
      print("El valor de num es ${MemoriaStatica.num}");
    }
  }
  void main() {
    MemoriaStatica.num = 12;
    // Inicializamos la variable estática}
    MemoriaStatica.disp();
    // invocamos el  método estático
  }
#+END_SRC

Esto producirá la siguiente salida - 

: El valor de num es 12

** La palabra clave /super/

La palabra clave *super* es usada para referirse a la clase padre inmediata. La palabra clave puede ser usada para referirse a la versión de una *variable, propiedad o método* de una superclase. El siguiente ejemplo ilustra esto - 

/Ejemplo/

#+BEGIN_SRC dart
  void main(){
    Hijo h = new Hijo();
    h.m1(12);
  }
  class Padre {
    String msg = "variable mensaje desde la clase padre";
    void m1(int a){ print("valor de a ${a}");}
  }
  class Hijo extends Padre {
    @override
    void m1(int b) {
      print("valor de b ${b}");
      super.m1(13);
      print("${super.msg}");
    }
  }
#+END_SRC


La salida que se producirá será la siguiente - 

: valor de b 12
: valor de a 13
: variable mensaje desde la clase padre

* Objetos 

Una programación orientada a objetos define un objeto como "cualquier entidad que tiene un límite definido". Un objeto tiene lo siguiente - 

+ *Estado* - Describe el objeto. El campo de una clase representa el estado del objeto 
+ *Comportamiento* - Describe lo que el objeto puede hacer 
+ *Identidad* - Un valor único que distingue un objeto de un conjunto de otros objetos similares. Dos o más objetos puede compartir el estado y el comportamiento pero no la identidad. 

El operador punto *(.)* es usado en conjunción con el objeto para acceder a los miembros datos de una clase. 

*Ejemplo*

Dart representa datos en la forma de objetos. Cada clase en Dart extiende la clase Objeto. Veremos en el siguiente ejemplo como crear y usar un objeto. 

#+BEGIN_SRC dart
  class Estudiante {
    void metodo_prueba() {
      print("Esto es un método de prueba");
    }
    void metodo_prueba1(){
      print("Esto es un método de prueba1");
    }
  }
  void main() {
    Estudiante e1 = new Estudiante();
    e1.metodo_prueba();
    e1.metodo_prueba1();
  }
#+END_SRC

La salida que producirá será - 

: Esto es un método de prueba
: Esto es un método de prueba1

** El operador Cascada (..)

En el ejemplo anterior hemos invocado el método en la clase. Sin embargo, cada vez que una función es llamada, una referencia al objeto es requerida. El *operador cascada* puede ser usado como un atajo en casos donde hay una secuencia de invocaciones. 

El operador cascada (..) puede ser usado para facilitar una secuencia de llamada vía un objeto. El ejemplo anterior puede ser reescrito de la siguiente manera. 

#+BEGIN_SRC dart
  class Estudiante {
    void metodo_prueba(){
      print("Esto es un método de prueba");
    }

    void metodo_prueba1(){
      print("Esto es un método de prueba");
    }
  }
  void main(){
    new Estudiante()
    ..metodo_prueba()
    ..metodo_prueba1();
  }
#+END_SRC

Esto producirá la siguiente salida 

: Esto es un método de prueba
: Esto es un método de prueba1

** El método /toString()/

Esta función devuelve una cadena de texto representación de un objeto. Veamos el siguiente ejemplo para entender como se usa el método *toString*

#+BEGIN_SRC dart
  void main() {
    int n = 12;
    print(n.toString());
  }
#+END_SRC

Esto dará como resultado -- 

: 12

* Colecciones 

Dart, a diferencia de otros lenguajes de programación, no soporta arrays. Las colecciones en Dart pueden ser usadas para replicar estructuras de datos como un array. La librería Dart:core y otras clases habilitan el soporte de Colecciones en los guiones de Dart. 

Las colecciones de Dart pueden ser basicamente clasificadas como - 

| Sr.No | Colecciones Dart | Descripción                                                                                                         |
|-------+------------------+---------------------------------------------------------------------------------------------------------------------|
|     1 | Lista            | Una lista es un simple grupo de objetos ordenados. Tenemos *Listas de longitud fija* y *Listas ampliables*          |
|     2 | Conjuntos        | Representan un colección de objetos cuyo objeto solo puede aparecer una vez.                                        |
|     3 | Mapas            | Es un para palabra/valor. Las palabras y valores pueden ser de cualquier tipo y son dinámicos, pueden ser ampliados |
|     4 | Cola             | Es una colección que puede ser manipulada en ambos finales. Los elementos se eliminan en el orden de su inserción  |


** Iterando colecciones 

La clase /Iterator/ de la biblioteca *dart:core* habilita la fácil colección transversal. Cada colección tiene una propiedad iterada. Esta propiedad devuelve un iterador que apunta al objeto en la colección. 

/Ejemplo/

El siguiente ejemplo ilustra atravesar una colección usando un objeto iterador.

#+BEGIN_SRC dart
  import 'dart:collection';
  void main() {
    Queue numC = new Queue();
    numC.addAll([100,200,300]);
    Iterator i= numC.iterator;

    while(i.moveNext()){
      print(i.current);
    }
  }
#+END_SRC

La función *moveNext()* devuelve un valor buleano indicado donde hay una subsecuencia. La propiedad *current* del objeto iterador devuelve el valor del objeto  al que el iterador apunta. 

Este programa producirá la siguiente salida - 

: 100 
: 200
: 300

* Genéricos

Dart es un *lenguaje tipado opcional*. Las colecciones en Dart son heterogéneas por defecto. En otras palabras, una simple colección en Dar puede hospedar valores de varios tipos. Sin embargo, una colección en Dart puede ser hecha manteniendo los valores homogéneos. El concepto de Genéricos puede ser usado para guardar lo mismo. 

El uso de Genéricos fuerza a una restricción en los tipos de datos de los valores que puede ser contenido en la colección. Tales colecciones son llamadas colecciones de tipo salvado. El tipo salvado es una característica que asegura que un bloque de memoria puede solamente contener datos de un tipo especificado. 

Todas las colecciones en Dart soportan esto vía genéricos. Un par corchetes angulares conteniendo el tipo de dato es usado para declarar una colección de tipo salvado. La sintaxis para declarar una colección de este tipo se ve a continuación. 

/Sintaxis/

: Nombre_colección <tipo_de_dato> identificador= new Nombre_colección<tipo_de_dato> 

La implementación tipo-salvado de una Lista, Mapa, Conjunto y Colas es dado a continuación. Esta característica es también soportada por todas las implementaciones de los tipos antes mencionados. 

/Ejemplo: Lista Genérica/

#+BEGIN_SRC dart
  void main(){
    List <String> logTypes = new List <String>();
    logTypes.add("ALERTA");
    logTypes.add("ERROR");
    logTypes.add("INFORMACIÓN");

    // iterando a través de la lista
    for (String type in logTypes){
      print(type);
    }
  }
#+END_SRC

Esto producirá la siguiente *Salida*

: ALERTA
: ERROR
: INFORMACIÓN


Un intento de insertar otro tipo de dato dará como resultado un error de compilación. El siguiente ejemplo ilustra esto.

/Ejemplo/

#+BEGIN_SRC dart
  void main() { 
    List <String> logTypes = new List <String>(); 
    logTypes.add(1); 
    logTypes.add("ERROR"); 
    logTypes.add("INFO"); 

    //iterating across list 
    for (String type in logTypes) { 
      print(type); 
    } 
  } 
#+END_SRC

La salida será la siguiente 

#+BEGIN_SRC

Error: The argument type 'int' can't be assigned to the parameter type 'String'.
Try changing the type of the parameter, or casting the argument to 'String'.
  logTypes.add(1);

#+END_SRC

/Ejemplo: Conjunto/

#+BEGIN_SRC dart
  void main(){
    Set <int>numberSet = new Set<int>();
    numberSet.add(100);
    numberSet.add(20);
    numberSet.add(5);
    numberSet.add(60);
    numberSet.add(70);

    for(var no in numberSet) {
      print(no)
    }
  }
#+END_SRC

La salida será. 

: 100
: 20
: 5
: 60
: 70

/Ejemplo de cola/

#+BEGIN_SRC dart
  import 'dart:collection';
  void main(){
    Queue<int> cola = new Queue<int>();
    print("Implementación por defecto ${cola.runtimeType}");
    cola.addLast(10);
    cola.addLast(20);
    cola.addLast(30);
    cola.addLast(40);
    queue.removeFirst();

    for(int no in cola){
      print(no);
    }
  }
#+END_SRC

La *Salida* será:

: Implementación por defecto ListQueue<int>
: 20
: 30
: 40

** Mapa genérico

Para declarar un mapa con tipos de datos específicos - 

+ La clave
+ El valor 

/Sintaxis/

: Map <tipo_de_clave, tipo_de_valor>

/Ejemplo/

#+BEGIN_SRC dart
    void main(){
      Map <String,String>m={'nombre':'Pedro','Id':'E1001'};
      print('Mapa :${m}');
    }
#+END_SRC


Esto dará como resultado lo siguiente

: Mapa :{nombre: Pedro, Id: E1001}
